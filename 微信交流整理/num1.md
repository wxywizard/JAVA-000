>大佬，想问下不用的对象置为null，对于gc来说是否是有必要的呢，我看好多源码里有这样操作的。
>
>如果是对象的属性，有必要
>
>如果是本地变量，无必要
>
>如果是一个局部变量的话是不是更没必要了
>
>对象A还有用，其中一个字段没用了，置null，就相当于让这个字段本身的对象B，跟A的引用关系断开了
>
>局部变量们，超出作用域，就自动（作为一个整体）没有引用关系了
>
>这些局部变量相互之间引用了，不关心
>
>就像，课上那个循环引用的例子
>
>古老的几千上万行的大型批处理代码中，可能有作用
>
>另外，C/C++ 转换写Java的程序员，典型的几个特点
>1、用完对象置null
>2、恨不得每行代码加个log
>3、特别喜欢用数组
>4、特别喜欢用静态字段和方法

- next

> 是这样的，之前有一次生产的事故，系统流量突然增大，表现是单个节点cup占用100%，紧接着这个集群挂掉，后来加节点加内存都不好使，基本上运行一小时后就会频繁fullgc导致cup占有过高，开始是怀疑有内存泄漏，但是DBA发现数据库有慢sql，这会导致查询出来的list会很大，耗时也长，改完sql调完数据库性能后，就好了。但是我还是不知道频繁fullgc的原因。对于这种情况list置为null是否有用呢？@秦金卫(kimmking)

>
>
>有时候，并没有真正的内存泄漏，还是会出现oom或者你描述的问题，fgc频繁，cpu飙升，，，最核心的问题其实是：单位时间内new对象使用的内存，超过了平时gc的回收能力。
>
>@吴东东 超出了系统设计的容量限制，比如作业系统只支持1-2个任务同时运行，却收到10个重型请求，又没有做好限流或排队。
>
>系统容量问题也就是资源问

> 举个例子：
> 1、平时肝脏新细胞产生(new)的频率不高 ~ 老细胞死亡(GC)的频率。所以人体很健康，心情很happy。绝大部分情况下，就是这样。
> 2、非常少的情况下，如果新细胞产生(new)的频率 远大于 老细胞死亡的频率，这就是肿瘤，然后变成癌症OOM掉了。
> 3、还有一种情况就是，所谓的亚健康，就像肝脏新细胞产生(new)的频率不低 ~ 老细胞死亡(GC)的频率也能跟得上，这个时候，最大的问题不是变成癌症，而是身体需要大量的资源去消灭新产生的细胞，所以系统看起来没奔溃，但是也算不上健康。
>
- next
> 那么减少tomcat的线程数和等待排队的长度应该对这种情况是有效的吧@秦金卫(kimmking)
> 这也是限流的一种，后面的课程里会讲系统稳定性和微服务，里面的限流控制有三个层次：
1、流量控制
2、服务降级
3、过载保护
> 另外，这种情况，通常来讲，可以先考虑优化内存的使用。比如我们之前一个网关系统，用100G的堆内存，一次访问要消耗大几百M内存，通过减少对象的属性，压缩字段，甚至使用部分二进制方式传递数据，最后把堆降低到16G
> 流量控制里有：
1、访问并发数控制
2、单位时间调用次数或数据量控制
3、关键节点并发处理线程数控制

- next

> 英文好的同学看下这两个文档
> https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#allocation_evacuation_failure
> https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html
>
> G1是为了大堆设计的，小堆跑起来优势不明显，至少需要 6GB
> 默认的并行回收线程数ParallelGCThreads 在 8核及以下机器是CPU数目，超过是 5/8，
> 并发标记线程数ConcGCThreads 是 ParallelGCThreads的 1/4

- next

<img src="资源\微信图片_20201029180812.png" alt="微信图片_20201029180812" style="zoom:50%;" />

> 这个图可以加深理解
>
> 很正常呀，ccs区的数据是开启压缩指针后，从原来的meta区挪过来的
>
> 单独划分了一个池子，但内存管理器都是同一个
>
> 也就是说，如果不开启压缩指针（默认小于32g内存都开启），就没这个区，本来这个区的数据就放到了meta区
>
> jvisualvm.exe -J-XX:+UseG1GC -J-XX:-UseCompressedOops

<img src="资源\微信图片_20201029180844.png" alt="微信图片_20201029180844" style="zoom:50%;" />

> 果然没了
>
> 各位同学有兴趣可以自己试验一番。