##### java特性
- GC不仅仅是释放内存做垃圾回收器，还是jvm和java的内存管理工具
- 运行时问题，有运行时就意味代码在整个运行的过程需要有上下文环境，有虚拟机运行时一般就是虚拟机，有一些没有虚拟机的语言可能也有运行时，现在还有GC（在编译的过程中就可以扫描到哪些对象在执行到哪一步是可以被干掉的，在编译的过程中我们把代码插进这个地方，生成的最终执行的这些指令里面有一步，最终要把前面申请的内存对象给干掉，这样就不需要一个单独的虚拟机和单独的GC模块，例如golang、rust）
- 编程语言跨平台
<img src="资源\Image.png" style="zoom:50%;" />

##### jvm运行hello world过程

- 字节码文件 --> 通过类加载器加载 --> 内存
- java字节码最大的用处是，当我们去研究一段代码的细节，或者一段代码和另外一段代码它的功能相同但是写法不一样，有什么本质差异的时候，一般可以通过字节码找到根本的原因。
- 什么是字节码
<img src="资源\Image [1].png" style="zoom:50%;" />

- jvm是一个基于栈的计算机，所有的计算都发生在栈上
- jvm都是基于栈的操作，除了栈以外它还有一个本地变量表，所有的计算都是在栈上，但是变量和变量的值都是存在本地变量表里，它怎么参数计算？在运行的时把变量移到栈上，在运行完了以后把栈上的值store回本地变量表，这样它需要有load和store的操作
<img src="资源\Image [2].png" style="zoom:50%;" />

- 字节码的运行时结构
<img src="资源\Image [3].png" style="zoom:50%;" />

- 对于字节码操作int是最小单位
- 在java代码中定义一个boolean，实际上字节码操作的时候还是把它当做一个32位的数据来处理的
- int和long操作起来是不是原子性的？一个int32位一个long64位，也就是一个long它由两个32位来组成，这样的话假如说我们的cpu带宽是32位的，那么每次cpu处理数据的时候只能处理32位，那么long它就得处理两次。假如说它处理第一次的时候，因为某个原因出错了操作被中断了，它可能后面的一半的32位就没处理成功，那么就导致了它现在给这个long赋值的时候，赋出来的值是错的，比如说要赋值100200，只把高位赋值了，后面的没赋值，最后操作的结果是10000，明显数据是错的，在32位的机器上这种情况有可能出现，但是在目前64位的机器上，其实每次我们的计算机处理都是可以直接处理64位的，而不用分成两个32位来处理。所以目前主流的jvm实现只要是64位的这几种类型都是原子操作。
- 对象的方法调用指令
<img src="资源\Image [4].png" style="zoom:50%;" />

##### jvm类加载器
- 类的生命周期

<img src="资源\Image [5].png" style="zoom:75%;" />

- 类的加载时机
<img src="资源\Image [6].png" style="zoom:75%;" />

- 哪些情况下类不会被初始化但可能被加载了

<img src="资源\Image [7].png" style="zoom:75%;" />

- 对象的引用在jvm里相当于一个对象指针，那么定义任何一个对象的数组长度是固定的，默认都会占32位的指针的长度，32位也就是4个字节乘以数组的长度就是数据需要的内存总的长度，跟它具体是什么对象的类型其实是没有关系的。
- 三类加载器
<img src="资源\Image [8].png" style="zoom:50%;" />
> 启动类加载器，主要用来加载jvm依赖的最核心的系统类，典型的就是jvm最系统的类都在一个叫rt.jar，常见的java lang util

> 扩展类加载器，是加载jdk有一个可以配置叫扩展类路径的这样一个目录，这个目录里有jar或者class文件

> 应用类加载器，主要加载业务代码，jar包

- jvm是怎么避免类被重复加载的呢？主要就是加载器的几个特点
> 双亲委托，我们的应用类加载器需要使用一个类的时候，它会先去看一下它的父类加载器中是不是已经有这个类被加载了，如果有它就直接用了，如果它的父加载器没有，它就会再上一级，去它的主父类加载器看有没有，如果有就用了。
> 负责依赖，我们加载这个类之后发现它依赖于另外一个类，它同样的需要去找依赖的这个类，这就是说我们加载一个类就要去负责加载跟它相关的类。
> 缓存加载，一个类被一个类加载器加载了完了以后它只会加载一次，在内部将它缓存起来，下次需要用的时候直接就用这个类了。所以对每个类加载器来说同一个类型它只加载一次。

- 在程序运行的时候给程序添加引用的类
<img src="资源\Image [9].png" style="zoom:50%;" />

##### jvm内存模型
- jvm内存结构
<img src="资源\Image [10].png" style="zoom:50%;" />

> jvm是基于堆栈的，new出来的对象都在堆上，因为对象是有生命周期的，但是线程用到的栈，一个方法执行完之后刚才那个栈和它的结构可能就不要了，所以线程的栈的生命周期可能更短，第二个一个对象有多大、占用多少内存我们可能不知道，但是一个栈它的方法多长、栈的深度是多少，我们一开始就知道。基于这些不同我们就可以把堆内存和栈内存分开，堆内存用来存我们的对象，然后线程的栈它要用到这些对象，这些堆上的东西它要怎么用呢？不对对象占多大内存在栈上表示的时候，它就是一个指针（int类型），
> 每个线程访问的是自己的栈，但是整个堆是大家共用的，在堆栈里用到对象的时候全部都是引用，只有栈具备计算能力

- 一个机器假如有4g内存，一般情况下配的xmx不超过总内存的70%

- 年轻代放新创建的对象，存活周期短的对象，老年代放要么是特别大的对象，要么是已经存活了一段时间的对象，这样的话我们处理这两个代，一般情况下可能用到的办法GC的方式也是不同的。
- jmm

<img src="资源\Image [11].png" style="zoom:50%;" />